// ---
//2017-12-19 08:55:03 Discover âž«âŸª#      0 0xd4e5674â€¦âŸ« ~âŸª   0 blks    0 txs  0 mgas  /secâŸ« âœŒï¸Žï¸Žï¸ŽâŸª 1/25 peersâŸ«  qos=âŸªrtt=18s ttl=1m0s conf=1.00âŸ«
//2017-12-19 08:55:17 â—¼â‹¯â‹¯â¬‡ Start âŸªPeer id=931f21921fcc7654 eth/63 [Parity/v1.8.3-beta-b49c44a-20171114/x86_64-linux-gnu/rustc1.21.0] [hs 0.00/s, bs 0.00/s, rs 0.00/s, ss 0.00/s, miss    0, rtt 20s]âŸ« hash=âŸª0xc5ea430â€¦âŸ« TD=âŸª185549045030301150788âŸ«
//2017-12-19 08:55:19 â—¼â‹¯â‹¯â Insert headers=âŸªprocessed=   0 ignored= 192âŸ« â=âŸªn=1836399 hash=0x1ecf991â€¦âŸ«took=âŸª73.546msâŸ«
//2017-12-19 08:55:20 â—¼â‹¯â‹¯â Insert headers=âŸªprocessed=   0 ignored= 192âŸ« â=âŸªn=1836591 hash=0xcff7c3câ€¦âŸ«took=âŸª275.686msâŸ«
//2017-12-19 08:57:25 â—¼â‹¯â‹¯â¬‡ Fail  âŸªPeer id=931f21921fcc7654 eth/63 [Parity/v1.8.3-beta-b49c44a-20171114/x86_64-linux-gnu/rustc1.21.0] [hs 211.71/s, bs 124.20/s, rs 184.06/s, ss 735.50/s, miss    0, rtt 1.512187158s]âŸ« err=âŸªcontent processing canceled (requested)âŸ«
//2017-12-19 09:00:43 â—¼â‹¯â‹¯â¬‡ Start âŸªPeer id=f30acc4f9c1a4369 eth/63 [Parity/v1.8.4-beta-c74c8c1-20171211/x86_64-linux-gnu/rustc1.22.1] [hs 0.00/s, bs 0.00/s, rs 0.00/s, ss 0.00/s, miss    0, rtt 20s]âŸ« hash=âŸª0x26f9a91â€¦âŸ« TD=âŸª185552382866154347587âŸ«
//2017-12-19 09:00:46 Sync ï¸Žâ—‰âŸª#5043160 0xed71befâ€¦âŸ« ~âŸª   0 blks    0 txs  0 mgas  /secâŸ« âœŒï¸Žï¸Žï¸ŽâŸª 5/25 peersâŸ« height=âŸª5047421 99.92%âŸ« qos=âŸªrtt=15.942s ttl=1m0s conf=0.70âŸ«
//2017-12-19 09:00:51 â—¼â‹¯â‹¯â—¼ Insert blocks=âŸªprocessed=  48 queued=   0 ignored=   0 txs= 341âŸ« â—¼=âŸªn= 5043208 hash=0x195123câ€¦ time=16h55m40.639s agoâŸ« took=âŸª5.692sâŸ«
//2017-12-19 09:01:47 Sync ï¸Žâ—‰âŸª#5044175 0xedb389dâ€¦âŸ« ~âŸª  16 blks  142 txs  3 mgas  /secâŸ« âœŒï¸Žï¸Žï¸ŽâŸª 8/25 peersâŸ« height=âŸª5047421 99.94%âŸ« qos=âŸªrtt=9.585s ttl=36.603s conf=0.87âŸ«
//2017-12-19 09:02:43 â—¼â‹¯â‹¯â—¼ Insert blocks=âŸªprocessed=2048 queued=   0 ignored=   0 txs=17899âŸ« â—¼=âŸªn= 5045256 hash=0xcf3d3fbâ€¦ time=8h49m5.014s agoâŸ« took=âŸª1m51.251sâŸ«
//2017-12-19 09:03:47 Sync ï¸Žâ—‰âŸª#5046394 0x8b10bddâ€¦âŸ« ~âŸª  36 blks  306 txs  9 mgas  /secâŸ« âœŒï¸Žï¸Žï¸ŽâŸª11/25 peersâŸ« height=âŸª5047421 99.98%âŸ« qos=âŸªrtt=6.695s ttl=22.328s conf=1.00âŸ«
//2017-12-19 09:04:43 â—¼â‹¯â‹¯â—¼ Insert blocks=âŸªprocessed=2048 queued=   0 ignored=   0 txs=18124âŸ« â—¼=âŸªn= 5047304 hash=0xc0b4780â€¦ time=33m45.455s agoâŸ« took=âŸª2m0.462sâŸ«
//2017-12-19 09:04:50 â—¼â‹¯â‹¯â¬‡ Done  âŸªPeer id=f30acc4f9c1a4369 eth/63 [Parity/v1.8.4-beta-c74c8c1-20171211/x86_64-linux-gnu/rustc1.22.1] [hs 813.97/s, bs 295.27/s, rs 0.00/s, ss 0.00/s, miss    0, rtt 1.918361657s]âŸ« hash=âŸª0x26f9a91â€¦âŸ« TD=âŸª185552382866154347587âŸ«
//2017-12-19 09:04:50 â—¼â‹¯â‹¯â—¼ Insert blocks=âŸªprocessed= 118 queued=   0 ignored=   0 txs=1183âŸ« â—¼=âŸªn= 5047422 hash=0xc47a4fcâ€¦ time=4m24.711s agoâŸ« took=âŸª7.258sâŸ«
//2017-12-19 09:04:51 â—¼â‹¯â‹¯â¬‡ Start âŸªPeer id=f30acc4f9c1a4369 eth/63 [Parity/v1.8.4-beta-c74c8c1-20171211/x86_64-linux-gnu/rustc1.22.1] [hs 0.00/s, bs 0.00/s, rs 0.00/s, ss 0.00/s, miss    0, rtt 1.918361657s]âŸ« hash=âŸª0x249c344â€¦âŸ« TD=âŸª185554240788446349916âŸ«
//2017-12-19 09:04:52 â—¼â‹¯â‹¯â—¼ Insert blocks=âŸªprocessed=   4 queued=   0 ignored=   0 txs=  53âŸ« â—¼=âŸªn= 5047426 hash=0x6aff1b9â€¦ time=3m21.897s agoâŸ« took=âŸª185msâŸ«
//2017-12-19 09:04:53 â—¼â‹¯â‹¯â¬‡ Done  âŸªPeer id=f30acc4f9c1a4369 eth/63 [Parity/v1.8.4-beta-c74c8c1-20171211/x86_64-linux-gnu/rustc1.22.1] [hs 0.00/s, bs 1.18/s, rs 0.00/s, ss 0.00/s, miss    0, rtt 1.743539409s]âŸ« hash=âŸª0x249c344â€¦âŸ« TD=âŸª185554240788446349916âŸ«
//2017-12-19 09:04:53 â—¼â‹¯â‹¯â—¼ Insert blocks=âŸªprocessed=  11 queued=   0 ignored=   0 txs= 119âŸ« â—¼=âŸªn= 5047437 hash=0x3950d3dâ€¦ time=1m27.504s agoâŸ« took=âŸª735msâŸ«
//2017-12-19 09:09:53 â—¼â‹¯â‹¯â—¼ Insert blocks=âŸªprocessed=  13 queued=   0 ignored=   0 txs= 124âŸ« â—¼=âŸªn= 5047453 hash=0xff69a28â€¦ time=19.599s agoâŸ« took=âŸª630msâŸ«
//2017-12-19 09:10:11 â—¼â‹¯â‹¯â—¼ Insert blocks=âŸªprocessed=   1 queued=   0 ignored=   0 txs=   1âŸ« â—¼=âŸªn= 5047454 hash=0xd03268aâ€¦ time=34.122s agoâŸ« took=âŸª8msâŸ«
//2017-12-19 09:10:18 â—¼â‹¯â‹¯â—¼ Insert blocks=âŸªprocessed=   1 queued=   0 ignored=   0 txs=   7âŸ« â—¼=âŸªn= 5047455 hash=0x1364b57â€¦ time=13.649s agoâŸ« took=âŸª17msâŸ«
//2017-12-19 09:10:25 â—¼â‹¯â‹¯â—¼ Insert blocks=âŸªprocessed=   1 queued=   0 ignored=   0 txs=   6âŸ« â—¼=âŸªn= 5047456 hash=0x00ee977â€¦ time=12.328s agoâŸ« took=âŸª23msâŸ«
// ---

package main

import (
	"time"
	"fmt"
	"math/big"
	"github.com/ethereumproject/go-ethereum/logger"
	"strings"
	"github.com/ethereumproject/go-ethereum/logger/glog"
	"github.com/ethereumproject/go-ethereum/eth"
	"github.com/ethereumproject/go-ethereum/eth/downloader"
	"gopkg.in/urfave/cli.v1"
	"github.com/ethereumproject/go-ethereum/core"
)

var lsModeIcon = []string{
	"",
	"ï¸Žâ—‰",
	"â—Ž",
	"â–¶ï¸Ž",
}

var dominoes = []string{"ðŸ£", "ðŸ¤", "ðŸ¥", "ðŸ¦", "ðŸ­", "ðŸ´", "ðŸ»", "ðŸ¼", "ðŸ‚ƒ", "ðŸ‚„", "ðŸ‚‹", "ðŸ‚Œ", "ðŸ‚“"} // ðŸ£ðŸ¤ðŸ¥ðŸ¦ðŸ­ðŸ´ðŸ»ðŸ¼ðŸ‚ƒðŸ‚„ðŸ‚‹ðŸ‚ŒðŸ‚“
var chainIcon = "â—¼â‹¯â‹¯" + logger.ColorGreen("â—¼")
var forkIcon = "â—¼â‹¯â¦¦" + logger.ColorGreen("â—¼")
var headerIcon = "â—¼â‹¯â‹¯" + logger.ColorGreen("â")
var downloaderIcon = "â—¼â‹¯â‹¯" + logger.ColorGreen("â¬‡")
var minedIcon = "â—¼â‹¯â‹¯" + logger.ColorGreen("âŸ ")
var lsModeDiscoverSpinners = []string{"âž«", "âž¬", "âž­"}

func greenParenify(s string) string {
	return logger.ColorGreen("âŸª") + s + logger.ColorGreen("âŸ«")
}
func redParenify(s string) string {
	return logger.ColorRed("âŸª") + s + logger.ColorRed("âŸ«")
}

// greenDisplaySystem is "spec'd" in PR #423 and is a little fancier/more detailed and colorful than basic.
var greenDisplaySystem = displayEventHandlers{
	{
		eventT: logEventChainInsert,
		ev:     core.ChainInsertEvent{},
		handlers: displayEventHandlerFns{
			func(ctx *cli.Context, e *eth.Ethereum, evData interface{}, tickerInterval time.Duration) {
				switch d := evData.(type) {
				case core.ChainInsertEvent:
					glog.D(logger.Info).Infof(chainIcon+" Insert "+logger.ColorGreen("blocks")+"=%s "+logger.ColorGreen("â—¼")+"=%s "+logger.ColorGreen("took")+"=%s",
						greenParenify(fmt.Sprintf("processed=%4d queued=%4d ignored=%4d txs=%4d", d.Processed, d.Queued, d.Ignored, d.TxCount)),
						greenParenify(fmt.Sprintf("n=%8d hash=%sâ€¦ time=%v ago", d.LastNumber, d.LastHash.Hex()[:9], time.Since(d.LatestBlockTime).Round(time.Millisecond))),
						greenParenify(fmt.Sprintf("%v", d.Elasped.Round(time.Millisecond))),
					)
					if bool(glog.D(logger.Info)) {
						chainEventLastSent = time.Now()
					}
				}
			},
		},
	},
	{
		eventT: logEventChainInsertSide,
		ev:     core.ChainSideEvent{},
		handlers: displayEventHandlerFns{
			func(ctx *cli.Context, e *eth.Ethereum, evData interface{}, tickerInterval time.Duration) {
				switch d := evData.(type) {
				case core.ChainSideEvent:
					glog.D(logger.Info).Infof(forkIcon+" Insert "+logger.ColorGreen("forked block")+"=%s", greenParenify(fmt.Sprintf("n=%8d hash=%sâ€¦", d.Block.NumberU64(), d.Block.Hash().Hex()[:9])))
				}
			},
		},
	},
	{
		eventT: logEventHeaderChainInsert,
		ev:     core.HeaderChainInsertEvent{},
		handlers: displayEventHandlerFns{
			func(ctx *cli.Context, e *eth.Ethereum, evData interface{}, tickerInterval time.Duration) {
				switch d := evData.(type) {
				case core.HeaderChainInsertEvent:
					glog.D(logger.Info).Infof(headerIcon+" Insert "+logger.ColorGreen("headers")+"=%s "+logger.ColorGreen("â")+"=%s"+logger.ColorGreen("took")+"=%s",
						greenParenify(fmt.Sprintf("processed=%4d ignored=%4d", d.Processed, d.Ignored)),
						greenParenify(fmt.Sprintf("n=%4d hash=%sâ€¦", d.LastNumber, d.LastHash.Hex()[:9])),
						greenParenify(fmt.Sprintf("%v", d.Elasped.Round(time.Microsecond))),
					)
					if bool(glog.D(logger.Info)) {
						chainEventLastSent = time.Now()
					}
				}
			},
		},
	},
	{
		eventT: logEventMinedBlock,
		ev:     core.NewMinedBlockEvent{},
		handlers: displayEventHandlerFns{
			func(ctx *cli.Context, e *eth.Ethereum, evData interface{}, tickerInterval time.Duration) {
				switch d := evData.(type) {
				case core.NewMinedBlockEvent:
					glog.D(logger.Info).Infof(minedIcon + " Mined " + logger.ColorGreen("â—¼") + "=" + greenParenify(fmt.Sprintf("n=%8d hash=%sâ€¦ coinbase=%sâ€¦ txs=%3d uncles=%d",
						d.Block.NumberU64(),
						d.Block.Hash().Hex()[:9],
						d.Block.Coinbase().Hex()[:9],
						len(d.Block.Transactions()),
						len(d.Block.Uncles()),
					)))
				}
			},
		},
	},
	{
		eventT: logEventDownloaderStart,
		ev:     downloader.StartEvent{},
		handlers: displayEventHandlerFns{
			func(ctx *cli.Context, e *eth.Ethereum, evData interface{}, tickerInterval time.Duration) {
				switch d := evData.(type) {
				case downloader.StartEvent:
					s := downloaderIcon + " Start " + greenParenify(fmt.Sprintf("%s", d.Peer)) + " hash=" + greenParenify(d.Hash.Hex()[:9]+"â€¦") + " TD=" + greenParenify(fmt.Sprintf("%v", d.TD))
					glog.D(logger.Info).Warnln(s)
				}
			},
		},
	},
	{
		eventT: logEventDownloaderDone,
		ev:     downloader.DoneEvent{},
		handlers: displayEventHandlerFns{
			func(ctx *cli.Context, e *eth.Ethereum, evData interface{}, tickerInterval time.Duration) {
				switch d := evData.(type) {
				case downloader.DoneEvent:
					s := downloaderIcon + " Done  " + greenParenify(fmt.Sprintf("%s", d.Peer)) + " hash=" + greenParenify(d.Hash.Hex()[:9]+"â€¦") + " TD=" + greenParenify(fmt.Sprintf("%v", d.TD))
					glog.D(logger.Info).Warnln(s)
				}
			},
		},
	},
	{
		eventT: logEventDownloaderFailed,
		ev:     downloader.FailedEvent{},
		handlers: displayEventHandlerFns{
			func(ctx *cli.Context, e *eth.Ethereum, evData interface{}, tickerInterval time.Duration) {
				switch d := evData.(type) {
				case downloader.FailedEvent:
					s := downloaderIcon + " Fail  " + greenParenify(fmt.Sprintf("%s", d.Peer)) + " " + logger.ColorRed("err") + "=" + redParenify(d.Err.Error())
					glog.D(logger.Info).Warnln(s)
				}
			},
		},
	},
	{
		eventT: logEventInterval,
		handlers: displayEventHandlerFns{
			func(ctx *cli.Context, e *eth.Ethereum, evData interface{}, tickerInterval time.Duration) {
				if time.Since(chainEventLastSent) > time.Duration(time.Second*time.Duration(int32(tickerInterval.Seconds()/2))) {
					currentBlockNumber = PrintStatusGreen(e, tickerInterval, ctx.GlobalInt(aliasableName(MaxPeersFlag.Name, ctx)))
				}
			},
		},
	},
}

// PrintStatusGreen implements the displayEventHandlerFn interface
var PrintStatusGreen = func(e *eth.Ethereum, tickerInterval time.Duration, maxPeers int) uint64 {
	lenPeers := e.Downloader().GetPeers().Len()

	rtt, ttl, conf := e.Downloader().Qos()
	confS := fmt.Sprintf("%01.2f", conf)
	qosDisplay := fmt.Sprintf("rtt=%v ttl=%v conf=%s", rtt.Round(time.Millisecond), ttl.Round(time.Millisecond), confS)

	_, current, height, _, _ := e.Downloader().Progress() // origin, current, height, pulled, known
	mode := e.Downloader().GetMode()
	if mode == downloader.FastSync {
		current = e.BlockChain().CurrentFastBlock().NumberU64()
	}

	// Get our head block
	blockchain := e.BlockChain()
	currentBlockHex := blockchain.CurrentBlock().Hash().Hex()

	// Discover -> not synchronising (searching for peers)
	// FullSync/FastSync -> synchronising
	// Import -> synchronising, at full height
	fOfHeight := fmt.Sprintf("%7d", height)

	// Calculate and format percent sync of known height
	heightRatio := float64(current) / float64(height)
	heightRatio = heightRatio * 100
	fHeightRatio := fmt.Sprintf("%4.2f%%", heightRatio)

	// Wait until syncing because real dl mode will not be engaged until then
	if currentMode == lsModeImport {
		fOfHeight = ""    // strings.Repeat(" ", 12)
		fHeightRatio = "" // strings.Repeat(" ", 7)
	}
	if height == 0 {
		fOfHeight = ""    // strings.Repeat(" ", 12)
		fHeightRatio = "" // strings.Repeat(" ", 7)
	}

	// Calculate block stats for interval
	numBlocksDiff := current - currentBlockNumber
	numTxsDiff := 0
	mGas := new(big.Int)

	var numBlocksDiffPerSecond uint64
	var numTxsDiffPerSecond int
	var mGasPerSecond = new(big.Int)

	var dominoGraph string
	var nDom int
	if numBlocksDiff > 0 && numBlocksDiff != current {
		for i := currentBlockNumber + 1; i <= current; i++ {
			b := blockchain.GetBlockByNumber(i)
			if b != nil {
				txLen := b.Transactions().Len()
				// Add to tallies
				numTxsDiff += txLen
				mGas = new(big.Int).Add(mGas, b.GasUsed())
				// Domino effect
				if currentMode == lsModeImport {
					if txLen > len(dominoes)-1 {
						// prevent slice out of bounds
						txLen = len(dominoes) - 1
					}
					if nDom <= 20 {
						dominoGraph += dominoes[txLen]
					}
					nDom++
				}
			}
		}
		if nDom > 20 {
			dominoGraph += "â€¦"
		}
	}
	dominoGraph = logger.ColorGreen(dominoGraph)

	// Convert to per-second stats
	// FIXME(?): Some degree of rounding will happen.
	// For example, if interval is 10s and we get 6 blocks imported in that span,
	// stats will show '0' blocks/second. Looks a little strange; but on the other hand,
	// precision costs visual space, and normally just looks weird when starting up sync or
	// syncing slowly.
	numBlocksDiffPerSecond = numBlocksDiff / uint64(tickerInterval.Seconds())

	// Don't show initial current / per second val
	if currentBlockNumber == 0 {
		numBlocksDiffPerSecond = 0
		numBlocksDiff = 0
	}

	// Divide by interval to yield per-second stats
	numTxsDiffPerSecond = numTxsDiff / int(tickerInterval.Seconds())
	mGasPerSecond = new(big.Int).Div(mGas, big.NewInt(int64(tickerInterval.Seconds())))
	mGasPerSecond = new(big.Int).Div(mGasPerSecond, big.NewInt(1000000))
	mGasPerSecondI := mGasPerSecond.Int64()

	// Format head block hex for printing (eg. d4eâ€¦fa3)
	cbhexstart := currentBlockHex[:9] // trim off '0x' prefix

	localHeadHeight := fmt.Sprintf("#%7d", current)
	localHeadHex := fmt.Sprintf("%sâ€¦", cbhexstart)
	peersOfMax := fmt.Sprintf("%2d/%2d peers", lenPeers, maxPeers)
	domOrHeight := fOfHeight + " " + fHeightRatio
	if len(strings.Replace(domOrHeight, " ", "", -1)) != 0 {
		domOrHeight = logger.ColorGreen("height") + "=" + greenParenify(domOrHeight)
	} else {
		domOrHeight = ""
	}
	var blocksprocesseddisplay string
	qosDisplayable := logger.ColorGreen("qos") + "=" + greenParenify(qosDisplay)
	if currentMode != lsModeImport {
		blocksprocesseddisplay = logger.ColorGreen("~") + greenParenify(fmt.Sprintf("%4d blks %4d txs %2d mgas  "+logger.ColorGreen("/sec"), numBlocksDiffPerSecond, numTxsDiffPerSecond, mGasPerSecondI))
	} else {
		blocksprocesseddisplay = logger.ColorGreen("+") + greenParenify(fmt.Sprintf("%4d blks %4d txs %8d mgas", numBlocksDiff, numTxsDiff, mGas.Uint64()))
		domOrHeight = dominoGraph
		qosDisplayable = ""
	}

	// Log to ERROR.
	headDisplay := greenParenify(localHeadHeight + " " + localHeadHex)
	peerDisplay := greenParenify(peersOfMax)

	modeIcon := logger.ColorGreen(lsModeIcon[currentMode])
	if currentMode == lsModeDiscover {
		// TODO: spin me
		modeIcon = lsModeDiscoverSpinners[0]
	}
	modeIcon = logger.ColorGreen(modeIcon)

	// This allows maximum user optionality for desired integration with rest of event-based logging.
	glog.D(logger.Warn).Infof("%s "+modeIcon+"%s %s "+logger.ColorGreen("âœŒï¸Žï¸Žï¸Ž")+"%s %s %s",
		currentMode, headDisplay, blocksprocesseddisplay, peerDisplay, domOrHeight, qosDisplayable)
	return current
}
